# -*- coding: utf-8 -*-
# =============================================
# Title:  Piece-wise Stationary SCM-MAB
# File:   nsscmmab.py
# Date:   10 July 2021
# =============================================


from copy import deepcopy
from networkx.classes import MultiDiGraph
from numpy import vectorize
from tqdm import trange

from npsem.bandits import play_bandits
from npsem.model import StructuralCausalModel, default_P_U
from npsem.scm_bandits import SCM_to_bandit_machine, arm_types, arms_of
from npsem.utils import subseq
from src.examples.example_setup import setup_DynamicIVCD
from src.utils.dag_utils.graph_functions import get_time_slice_sub_graphs, make_time_slice_causal_diagrams
from src.utils.postprocess import assign_blanket, get_results
from src.utils.transitions import fit_sem_hat_transition_functions, get_transition_pairs


class NSSCMMAB:
    """
    Assumptions:
    - Data is generated by a non-stationary process
    - We do not have access to the SEM so we need to estimate it
    - Assume that the model is piece-wise stationary
    """

    def __init__(
        self,
        G: MultiDiGraph,  #  A dynamic Bayesian network
        SEM: classmethod,
        mu1: dict,  # Reward distribution
        node_info: dict,  # Has to contain a domain key per manipulative variable
        confounder_info: dict,
        base_target_variable: str,
        horizon: int,
        n_trials: int,
        n_jobs: int,
        observational_samples: dict = None,
        arm_strategy: str = "POMIS",
        bandit_algorithm: str = "TS",  # Assumes that within time-slice bandit is stationary
    ):

        self.T = G.total_time
        time_slice_nodes = G.time_slice_manipulative_nodes
        # Extract all target variables from the causal graphical model
        self.all_target_variables = [s for s in G.nodes if s.startswith(base_target_variable)]
        sub_DAGs = get_time_slice_sub_graphs(G, self.T)
        # Causal diagrams used for making SCMs upon which bandit algo acts
        self.causal_diagrams = make_time_slice_causal_diagrams(sub_DAGs, confounder_info)

        self.transition_functions = None
        if observational_samples:
            # We use observed samples of the system to estimate the (discrete) structural equation model
            self.transfer_pairs = get_transition_pairs(G)
            self.transition_functions = fit_sem_hat_transition_functions(observational_samples, self.transfer_pairs)
            # TODO: (1) add estimates for emission edges; (2) combine it all in a sem_hat like function
        else:
            # We use the true structural equation model in the absence of observational samples
            self.sem = SEM()  #  Does not change throuhgout

        self.P_U = default_P_U(mu1)
        self.domains = {key: val["domain"] for key, val in node_info.items()}
        # Remains the same for all time-slices (just background variables)
        self.more_U = {key for key in node_info.keys() if key[0] == "U"}
        self.SCMs = {t: None for t in range(self.T)}

        # Bandit settings
        assert arm_strategy in arm_types()
        self.arm_strategy = arm_strategy
        assert bandit_algorithm in ["TS", "UCB"]
        self.play_bandit_args = {"T": horizon, "algo": bandit_algorithm, "n_trials": n_trials, "n_jobs": n_jobs}

        # Results
        self.results = {t: None for t in range(self.T)}
        self.reward_distribution = deepcopy(self.results)
        self.arm_setting = deepcopy(self.results)

        # Stores the intervention, and the downstream effect of the intervention, for each time-slice
        self.blanket = {t: {key: None for key in time_slice_nodes} for t in range(self.T)}
        self.empty_slice = {key: None for key in time_slice_nodes}

    # Play piece-wise stationary bandit
    def run(self):

        # Walk through the graph, from left to right, i.e. the temporal dimension
        for temporal_index in trange(self.T, desc="Time index"):

            # Get target for this time index
            target = self.all_target_variables[temporal_index]
            # Check that indices line up for this time-slice
            target_var_only, target_var_temporal_index = target.split("_")
            assert int(target_var_temporal_index) == temporal_index

            # Create SCM
            self.SCMs[temporal_index] = StructuralCausalModel(
                G=self.causal_diagrams[temporal_index],
                F=self.sem.static() if temporal_index == 0 else self.sem.dynamic(clamped=clamped_nodes),
                P_U=self.P_U,
                D=self.domains,
                more_U=self.more_U,
            )

            #  Convert time-slice SCM to bandit machine
            mu, arm_setting = SCM_to_bandit_machine(self.SCMs[temporal_index], target_variable=target_var_only)
            #  Select arm strategy, one of: "POMIS", "MIS", "Brute-force", "All-at-once"
            arm_selected = arms_of(self.arm_strategy, arm_setting, self.SCMs[temporal_index].G, target_var_only)
            arm_corrector = vectorize(lambda x: arm_selected[x])

            # Set the rewards distribution
            self.play_bandit_args["mu"] = subseq(mu, arm_selected)
            # Pick action/intervention by playing MAB
            arm_played, rewards = play_bandits(**self.play_bandit_args)
            arm_played = arm_corrector(arm_played)

            # Post-process
            self.results[temporal_index] = get_results(arm_played, rewards, mu)
            self.reward_distribution[temporal_index] = mu
            self.arm_setting[temporal_index] = arm_setting
            #  Get index of the best arm
            best_arm_idx = max(
                self.results[temporal_index]["frequency"], key=self.results[temporal_index]["frequency"].get
            )
            # Get the corresponding intervention of that index e.g. {'Z': 0}
            best_intervention = arm_setting[best_arm_idx]

            # Contains the optimal actions and corresponding output
            self.blanket[temporal_index] = assign_blanket(
                self.SCMs[temporal_index], deepcopy(self.empty_slice), best_intervention, target_var_only,
            )

            # Contains the _transferred_ (from t-1 to t) optimal actions and corresponding output, computed before passed to SEM at next time step.
            if self.transition_functions:
                clamped_nodes = {
                    var: self.transfer_function[temporal_index][var](val)
                    for var, val in self.blanket[temporal_index].items()
                    if self.blanket[temporal_index][var] is not None
                }
                # Assign empty to nodes which were not assigned above
                for node in self.blanket[temporal_index].keys() - (
                    clamped_nodes.keys() & self.blanket[temporal_index].keys()
                ):
                    if node:
                        clamped_nodes[node] = None
            else:
                clamped_nodes = self.blanket[temporal_index]


def main():
    """
    Test method with standard params.
    """
    params = setup_DynamicIVCD()
    m = NSSCMMAB(**params)
    m.run()


if __name__ == "__main__":
    main()
