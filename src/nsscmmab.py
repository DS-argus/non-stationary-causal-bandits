# -*- coding: utf-8 -*-
# =============================================
# Title:  Piece-wise Stationary SCM-MAB
# File:   nsscmmab.py
# Date:   10 July 2021
# =============================================

from npsem.utils import subseq
from npsem.model import StructuralCausalModel, default_P_U
from npsem.bandits import play_bandits
from npsem.scm_bandits import SCM_to_bandit_machine, arm_types, arms_of
from numpy import vectorize
from tqdm import trange
from utils.dag_utils.graph_functions import get_time_slice_sub_graphs, make_time_slice_causal_diagrams


class NSSCMMAB:
    """
    Assumptions:
    - Data is generated by a non-stationary process
    - We do not have access to the SEM so we need to estimate it
    - Assume that the model is piece-wise stationary
    """

    def __init__(
        self,
        G,
        SEM: classmethod,
        mu1: dict,  # Reward distribution
        domains: dict,
        node_info: dict,
        confounder_info: dict,
        base_target_variable: str,
        horizon: int,
        n_trials: int,
        n_jobs: int,
        arm_strategy="POMIS",
        bandit_algorithm="TS",
    ):

        T = max([int(s) for s in "".join(G.nodes) if s.isdigit()]) + 1
        # Extract all target variables from the causal graphical model
        self.all_target_variables = list(filter(lambda k: base_target_variable in k, G.nodes))
        sub_DAGs = get_time_slice_sub_graphs(G, T)
        # Causal diagrams used for making SCMs upon which bandit algo acts
        self.causal_diagrams = make_time_slice_causal_diagrams(sub_DAGs, node_info, confounder_info)
        sem = SEM()
        self.static_sem = sem.static()
        self.dynamic_sem = sem.dynamic()
        self.P_U = default_P_U(mu1)
        self.domains = domains
        # Remains the same for all time-slices
        self.more_U = {"U_{}".format(v) for v in self.causal_diagrams[0].V}

        self.SCMs = {t: None for t in range(T)}
        # TODO: prior for all edges in DBN

        assert arm_strategy in arm_types()
        self.arm_strategy = arm_strategy
        assert bandit_algorithm in ["TS", "UCB"]
        self.play_bandit_params = {"T": horizon, "algo": bandit_algorithm, "n_trials": n_trials, "n_jobs": n_jobs}

    def run(self):

        # Walk through the graph, from left to right, i.e. the temporal dimension
        for temporal_index in trange(self.total_timesteps, desc="Time index"):

            # Get target for this time index
            target = self.all_target_variables[temporal_index]
            # Check that indices line up for this time-slice
            _, target_temporal_index = target.split("_")
            assert int(target_temporal_index) == temporal_index

            # Create SCM, must take into account the optimal actions selected at t-1 if t > 0
            self.SCMs[temporal_index] = StructuralCausalModel(
                G=self.causal_diagrams[temporal_index],
                F=self.static_sem if temporal_index == 0 else self.dynamic_sem(clamped=optimal_node_setting),
                P_U=self.P_U,
                D=self.domains,
                more_U=self.more_U,
            )

            # Play this, piece-wise stationary bandit
            mu, arm_setting = SCM_to_bandit_machine(self.SCMs[temporal_index])
            arm_selected = arms_of(self.arm_strategy, arm_setting, self.SCMs[temporal_index].G, target)
            arm_corrector = vectorize(lambda x: arm_selected[x])

            # Pick action/intervention by playing MAB
            arm_played, rewards = play_bandits(mu=subseq(mu, arm_selected), **self.play_bandit_params)

            # Clamp nodes corresponding to the best intervention
            optimal_node_setting = None
            # Don't assign the wrong stuff (non-boolean)
            assert all(value == 0 or value == 1 for value in optimal_node_setting.values())

            # TODO: need to update statistics for next time-step through the transition functions (though this probably already happens in SCM_to_bandit_machine)
            # TODO: need to fix params in the SEM based on choices for this MAB

